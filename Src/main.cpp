/*
 * main.cpp
 *
 *  Created on: Sep 15, 2020
 *      Author: Nicklas Grunert (@github.com/LordSyFo)
 */

#include "main.h"

#include <Serial/I2C.h>
#include <Serial/USART.h>
#include <Serial/SPI.h>

#include <Util/InterruptWrapper.h>
#include <Util/Interruptable.h>

#include "ISRCallbacks.h"
#include <ESP32/Process.h>

#include <BusErrorDetection/CRCValidator.h>
#include <ESP32/CommandProcessors/CommandContainer.h>
#include <ESP32/CommandHandler.h>

#include <type_traits>

/* Realtime OS stuff */
#include <Thread/Events/Events.hpp>
#include <Thread/Thread.hpp>
#include "cmsis_os.h"

/* Image stuff */
#include <ESP32/CommandProcessors/VersionProcessor.h>

#include <string.h>
#include "AutogenMethods.h"

/* Autogenerated methods */
void Error_Handler(void);

/* Autogenerated instances */
CRC_HandleTypeDef hcrc;

I2C_HandleTypeDef hi2c1;

SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi1_rx;
DMA_HandleTypeDef hdma_spi1_tx;
DMA_HandleTypeDef hdma_spi2_rx;
DMA_HandleTypeDef hdma_spi2_tx;

UART_HandleTypeDef huart1;
TIM_HandleTypeDef htim1;

// Global interrupt wrappers
Util::InterruptWrapper dcmi_isr_wrapper;
Util::InterruptWrapper spiss_isr_wrapper;

void TaskWrapper(void* obj);

/* Thread handles */
osThreadId_t g_ESP32CommThread;

/* Static class instantiation */
// Serial classes
Serial::SPI 	g_SPI {hspi1, hdma_spi1_rx, hdma_spi1_tx};
Serial::I2C 	g_I2C {&hi2c1};
Serial::USART 	g_UART{&huart1};

// AIOCA Protocol classes
BusErrorDetection::CRCValidator g_CRC(&hcrc);	// Use CRC for error detection
ESP32::Communication g_ESP32Comm(&g_SPI,g_CRC);

// Command processors
ESP32::VersionProcessor versProcessor;

// TODO: The container should be able to deduce the amount of processors!
ESP32::CommandContainer<6> g_CommandContainer = {
		&versProcessor,
		&setProcessor,
		&vidStorageProcessor,
		&vidInfoProcessor,
		&vidDataProcessor,
		&userLoginProcessor
};

ESP32::CommandHandler g_CmdHandler(&g_CommandContainer,g_ESP32Comm);
ESP32::Process g_WiFiProcess(g_ESP32Comm, g_CmdHandler);

void TestThreadFunc(void*);

int main(){

	HAL_Init();

	/* Configure the system clock */
	SystemClock_Config();
	HAL_Delay(1000);	// Wait for OV7670 to turn on and stabilize

	// Initialize auto-generated methods
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_I2C1_Init();
	MX_USART1_UART_Init();
	MX_SPI1_Init();
	MX_DCMI_Init();
	MX_TIM1_Init();
	MX_CRC_Init();
	MX_SPI2_Init();
	MX_FATFS_Init();
	MX_JPEG_Init();

	HAL_Delay(1000);	// Wait for SD card to stabilize

	/* Init scheduler */
	osKernelInitialize();

	// Bind the DMA to the DCMI
	hdcmi.DMA_Handle = &hdma_dcmi_pssi;
	hdma_dcmi_pssi.Parent = &hdcmi;

	// Initialize interrupt wrappers
	spiss_isr_wrapper.ConnectInterruptableCallback((Util::Interruptable*)&g_SPI);

	// Setup thread util
	Thread::Initialize();	// Initializes all threading utilities

	/* Creation of ESP32 Comm thread */
	g_ESP32CommThread = Thread::CreateThread(TaskWrapper, (void*) &g_WiFiProcess, "WFT", osPriorityHigh);

	/* Start scheduler */
	osKernelStart();

	while(1)
	{
		// UNUSED AS THE SCHEDULER WILL TAKE CONTROL AFTER CALLING START!
	}

	return 1;
}

void TaskWrapper(void* obj){
	Util::AProcess* self = static_cast<Util::AProcess*>(obj);
	self->OnEnter();
	self->Run();
	self->OnExit();
	vTaskDelete( NULL);
}

void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
	for(;;){}
  /* USER CODE END Error_Handler_Debug */
}
